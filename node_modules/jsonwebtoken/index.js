const issuedTokens = new Map();
let counter = 0;

function toMillis(expiresIn) {
  if (!expiresIn && expiresIn !== 0) return null;
  if (typeof expiresIn === 'number' && Number.isFinite(expiresIn)) {
    return expiresIn * 1000;
  }
  if (typeof expiresIn !== 'string') return null;
  const match = /^\s*(\d+)\s*([smhd])?\s*$/i.exec(expiresIn);
  if (!match) return null;
  const value = Number.parseInt(match[1], 10);
  if (!Number.isFinite(value)) return null;
  const unit = match[2] ? match[2].toLowerCase() : 's';
  const unitMap = { s: 1000, m: 60_000, h: 3_600_000, d: 86_400_000 };
  return value * (unitMap[unit] || 1000);
}

export function sign(payload = {}, secret = '', options = {}) {
  const token = `stub.${Date.now()}.${++counter}`;
  const ttl = toMillis(options?.expiresIn);
  const expiry = ttl ? Date.now() + ttl : null;
  const storedPayload = typeof payload === 'object' && payload !== null
    ? { ...payload }
    : { value: payload };
  issuedTokens.set(token, { payload: storedPayload, secret: secret ?? '', expiry });
  return token;
}

export function verify(token, secret = '') {
  if (!issuedTokens.has(token)) {
    throw new Error('invalid token');
  }
  const entry = issuedTokens.get(token);
  if ((entry.secret ?? '') !== (secret ?? '')) {
    throw new Error('invalid signature');
  }
  if (entry.expiry && Date.now() >= entry.expiry) {
    const err = new Error('jwt expired');
    err.name = 'TokenExpiredError';
    throw err;
  }
  return { ...entry.payload };
}

export default { sign, verify };
